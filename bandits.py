#!/usr/bin/env python
#-*-coding: utf-8 -*-

from scipy import stats
import numpy as np


class BernoulliArm:
    # Bernoulli arm
    def __init__(self, p):
        self.bernoulli = stats.bernoulli(p)
        self.mean = self.bernoulli.mean()   # = p

    def pull(self):
        return self.bernoulli.rvs()

class BetaArm:
    # arm having a Beta distribution
    def __init__(self, a, b):
        self.beta = stats.beta(a,b)
        self.mean = self.beta.mean()        # = a / (a+b)

    def pull(self):
        return self.beta.rvs()

class ExpArm:
    # arm with truncated exponential distribution
    def __init__(self, lamb):
        self.lamb = float(lamb)
        self.mean = (1/float(lamb))*(1-np.exp(-lamb))   # = 1 / lambda
        self.var = 1

    def pull(self):
        reward = min(-1/self.lamb*np.log(np.random.rand()),1)
        return reward

class MAB:
    """
    Parameters:
    -----------
    L:  int
        Number of arms

    params: dictionary
        e.g. {
                "bernoulli": 0.5,
                "bernoulli": 0.3,
                "beta": [1, 3],
                "exp": 0.5
             }
    """
    def __init__(self, L, params=None):
        self.arms = list()
        if params is None:  # Default is Bernoulli of random means
            generator = stats.norm(0.5, 0.15)
            for i in xrange(L):
                # Mean generated by a Gaussian of mean 0.5 and standard
                # deviation 0.15. Must be within [0.05, 0.95]
                mu = max(min(generator.rvs(), 0.05), 0.95)
                self.arms.append(BernoulliArm(mu))
        else:
            if len(params) != L:
                return  # Better: throw exception
            for key in params:
                if key == "bernoulli":
                    self.arms.append(BernoulliArm(params[key]))
                elif key == "beta":
                    a, b = params[key]
                    self.arms.append(BetaArm(a, b))
                elif key == "exp":
                    self.arms.append(ExpArm(params[key]))

    def play(self,index):
        """ Play arm index and return the corresponding reward """
        return self.arms[index].pull()

class EstimatedArm:

    def __init__(self):
        self.estimated_mean = None
        self.UCB = None
        self.N = 0  # number of times this arm has been played so far

    def computeUCB(self, t):
        self.UCB = self.estimated_mean + sqrt(3*np.log(t)/(4*self.N))

    def updateEstimations(self, reward):
        """ Update estimations if we played one more round and received
        reward 'reward' """
        self.estimated_mean = (self.estimated_mean * self.N + reward) \
                              / (self.N + 1)
        self.N += 1

class EstimatedMAB:

    def __init__(self, L):
        self.L = L
        self.estimations = [EstimatedArm() for i in range(L)]
        self.UCBs = None

    def updateEstimatedArm(self, index, reward):
        if index >= len(self.estimations):
            return None # Better raise exception
        self.estimations[index].updateEstimations(reward)

    def computeUCB(self, index, t):
        if index >= len(self.estimations):
            return None # Better raise exception
        self.estimations[index].computeUCB(t)

    def computeUCBs(self, t):
        UCBs = list()
        for i in range(L):
            UCBs.append(self.estimations[i].computeUCB(t))
        self.UCBs = np.array(UCBs)

    def selectArms(self, K):
        """
        This functions selects K arms among the L ones depending on their UCBs.
        This is the function to change if you want to analyse the importance
        of the UCB values in the recommended list on the final regret.

        SO FAR: UCBs in reversed order
        """
        UCB_indices = list(self.UCBs.argsort())
        return reversed(UCB_indices)[:K]
